var buffer: []u8 = undefined;
var strBuffer: []u8 = undefined;

const Channel = struct {
  serverID:[]u8, ///to add as property in event hostory
  connected:bool,
  host:[]u8,
  port:[]u8,
  state:[3]i32,
  
  pub fn connect(self:*Channel, url:[]const u8, appId:i32) bool {
    const srv = getServer(serverID);
    self.port = getPort(url);
    self.host = getPort(url);
    self.connected = false;
    self.state[0] = 0;
    
    if(mem.eq(u8, srv.port, @constCast(self.port))
       && mem.eq(u8, srv.host, @constCast(self.host))) {
      if(srv.appId == appId) {
        if(!(appId > 1 && self.state[0] == 0)){
          self.connected = true;
          self.state[appId-1]=1;
        }
      }
    }
    return self.connected;
  }
  
  pub fn asHistoryChannel(self:Channel) HistoryChannel {
    var chan = HistoryChannel{};
    chan.channel = self;
    return chan;
  }
  
  pub fn asFlowChannel(self:Channel) FlowChannel {
    var chan = FlowChannel{};
    chan.channel = self;
    return chan;
  }
  
  pub fn asPlotChannel(self:Channel) PlotChannel {
    var chan = PlotChannel{};
    chan.channel = self;
    return chan;
  }
  
  pub fn asRepository(self:Channel) Repository {
    var chan = Repository{};
    chan.channel = self;
    return chan;
  }
}

const HistoryChannel = struct {
  channel: Channel,
  data: List(Strings),
  
  pub fn new(data:List(Strings)) HistoryChannel {
    return HistoryChannel {
      .data = data,
    };
  }
  
  pub fn connect(self:*HistoryChannel, url:[]const u8) void {
    self.channel.connect(url, 1);
  }
  
  pub fn save(self:*HistoryChannel, msg:[]const u8) !void {    
    try saveWriterString(self, history, msg);
  }
  
  pub fn asFlow(self:*HistoryChannel) void {
    self.channel.serverID == 2;
  }
  
  pub fn asPlot(self:*HistoryChannel) void {
    self.channel.serverID == 3;
  }
}  

fn saveWriterString(obj:anytype, filepath:[]const u8, result:[]const u8) !void {
  try Reader.read(filepath, &buffer);
  obj.data = json.parseJson(buffer);
  const len = self.data.len;
  self.data.items[len] = Strings.new(result);
    
  const jsonData = json.stringify(self.data.items);
    
  file.write(filepath, jsonData);
  buffer = undefined;
}

fn saveObject(obj:anytype, entity:anytype, filepath:[]const u8, result:anytype) !void {
  try Reader.read(filepath, &buffer);
  obj.data = json.parseJsonArray(entity, buffer);
  const len = obj.data.len;
  self.data[len] = result;
    
  const jsonData = json.stringify(obj.data);
    
  file.write(filepath, jsonData);
  buffer = undefined;
}

fn editObject(obj:anytype, entity:anytype, filepath:[]const u8, k:[]const u8, data:anytype) !void {
  try Reader.read(filepath, &buffer);
  obj.data = json.parseJsonArray(entity, buffer);
  const len = obj.data.len;
  var i=0;
  while(i<len) {
    if(mem.eq(@TypeOf(entity), obj.data[i].key, @constCast(k))) {
      obj.data[i].data = data;
      i=len;
    }
    i=i+1;
  }
  const jsonData = json.stringify(obj.data);
    
  file.write(filepath, jsonData);
  buffer = undefined;
}


const CacheRequest = struct {
  channel:Channel,
  data:List(Strings),
  
  pub fn new(urls:List(Strings)) CacheRequest {
    return CacheRequest {
      .data = urls,
    };
  }
  
  pub fn connect(self:*CacheRequest, url:[]const u8) void {
    self.channel.connect(url, 1);
  }
  
  pub fn addUrl(self:*CacheRequest, url:[]const u8) void {
    try saveWriterString(self, cache, url);
  }
  
  pub fn checkUrl(self:*CacheRequest, url:[]const u8) bool {
    try Reader.read(cache, &buffer);
    var result = json.parseJson(buffer);
    var i = 0;
    while(i<result.len) {
      if(mem.eq(u8, result[i], @constCast(url)) {
        return true;
      }
      i=i+1;
    }
    return false;
  }
}

const FlowChannel = struct {
  channel:Channel,
  consumers:[]Consumer,
  topics:[]Topic,
  
  pub fn new(c:List(Strings), t:List(Strings)) FlowChannel {
    return FlowChannel {
      .consumers = c,
      .topics = t,
    };
  }
  
  pub fn connect(self:*CacheRequest, url:[]const u8) void {
    self.channel.connect(url, 2);
  }
  
  pub fn asDatagramChannel(self:*FlowChannel) DatagramChannel {
    return DatagramChannel{.data=consumers};
  }
  
  pub fn asTopicChannel(self:*FlowChannel) TopicChannel {
    return asTopicChannel{.data=topics};
  }
  
}

const DatagramChannel = struct {
  data:[]Consumer,
  
  pub fn add(self:*DatagramChannel, c:Consumer) !void {
    try saveObject(self, Consumer{}, datagram, c);
  }
  
  pub fn edit(self:*DatagramChannel, k:[]const u8, data:anytype) !void {
    try editObject(self, Consumer{}, datagram, k, data);
  }
  
  pub fn get(self:*DatagramChannel) ![]Consumer {
    try Reader.read(filepath, &buffer);
    self.data = json.parseJsonArray(Consumer{}, buffer);
    return self.data;
  }
  
  pub fn getKey(self:*DatagramChannel, keyId:[]const u8) Consumer {
    const consumers = get(self);
    var i=0;
    while(i<consumers.len) {
      if(consumers[i].keyId == keyId) {
        return consumers[i];
      }
      i=i+1;
    }
    return undefined;
  }
}

const TopicChannel = struct {
  data:[]Topic,
  
  pub fn add(self:*TopicChannel, t:Topic) void {
    try saveObject(self, Topic{}, topic, t);
  }
  
  pub fn get(self:*TopicChannel) []Topic {
    try Reader.read(filepath, &buffer);
    self.data = json.parseJsonArray(Topic{}, buffer);
    return self.data;
  }
  
  pub fn getKey(self:*TopicChannel, id:i32) Topic {
    const topics = get(self);
    var i=0;
    while(i<topics.len) {
      if(topics[i].id == id) {
        return topics[i];
      }
      i=i+1;
    }
    return undefined;
  }
}

const PlotChannel = struct {
  channel:Channel,
  data:[]Dataset,
  
  pub fn new(data:[]Dataset) PlotChannel {
    return PlotChannel {
      .data = data,
    };
  }
  
  pub fn connect(self:*PlotChannel, url:[]const u8) void {
    self.channel.connect(url, 3);
  }
  
  pub fn save(self:*PlotChannel, d:Dataset) !void {
    try saveObject(self, Dataset{}, dataset, d);
  }
  
  pub fn get(self:*PlotChannel) []Dataset {
    try Reader.read(filepath, &buffer);
    self.data = json.parseJsonArray(Dataset{}, buffer);
    buffer = undefined;
    return self.data;
  }
  
  pub fn getId(self:*PlotChannel, id:[]const u8) Dataset {
    const all = get(self);
    var i=0;
    while(i<all.len) {
      if(all[i].id == id) {
        return all[i];
      }
      i=i+1;
    }
    return undefined;
  }
}

const Repository = struct {
  channel:Channel,
  data:[]EventHistory,
  
  pub fn new(data:[]EventHistory) Repository {
    return Repository {
      .data = data,
    };
  }
  
  pub fn connect(self:*Repository, url:[]const u8) void {
    self.channel.connect(url, 1);
  }
  
  pub fn save(self:*Repository, e:EventHistory) !void {
    try saveObject(self, EventHistory{}, history, e);
  }
  
  pub fn get(self:*Repository) []EventHistory {
    try Reader.read(filepath, &buffer);
    self.data = json.parseJsonArray(EventHistory{}, buffer);
    buffer = undefined;
    return self.data;
  }
  
  pub fn getId(self:*Repository, id:[]const u8) EventHistory {
    const all = get(self);
    var i=0;
    while(i<all.len) {
      if(all[i].id == id) {
        return all[i];
      }
      i=i+1;
    }
    return undefined;
  }
}

const NotificationChannel = struct {
  channel:Channel,
  data:[]Notification,
  
  pub fn new(data:[]Notification) NotificationChannel {
    return NotificationChannel {
      .data = data,
    };
  }
  
  pub fn connect(self:*NotificationChannel, url:[]const u8) void {
    self.channel.connect(url, 2);
  }
  
  pub fn save(self:*NotificationChannel, n:Notification) !void {
    try saveObject(self, Notification{}, notification, n);
  }
  
  pub fn get(self:*NotificationChannel) []Notification {
    try Reader.read(filepath, &buffer);
    self.data = json.parseJsonArray(Notification{}, buffer);
    buffer = undefined;
    return self.data;
  }
  
  pub fn getId(self:*NotificationChannel, id:[]const u8) Notification {
    const all = get(self);
    var i=0;
    while(i<all.len) {
      if(all[i].id == id) {
        return all[i];
      }
      i=i+1;
    }
    return undefined;
  }
}

