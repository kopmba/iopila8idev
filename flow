const Datagram = struct {
  id:i32,
  channel: Channel,
  
  pub fn connect(self:*Datagram, baseUrl:[]u8) void {
    const fchannel = self.channel.asFlowChannel();
    fchannel.connect(baseUrl);
  }
  
  pub fn disconnect(self:*Datagram) void {
    self.channel.connected = false;
    self.channel.state[0]=0;
  }
  
  pub fn lock(self:*Datagram, k:[]const u8) void {
    const repo = self.channel.asRepository();
    const list = repo.get();
    const consumer = self.read(k);
    var i = 0;
    while(i < list.len) {
      if(Strings.new(list[i].type.originalUrl).contains(k)
        && mem.eq(u8, consumer.status, @constCast("xxxx"))) {
        list[i].status = "lock";
        i=list.len;
      }
      i=i+1;
    }
  }
  
  pub fn unlock(self:*Datagram, k:[]const u8) void {
    const repo = self.channel.asRepository();
    const list = repo.get();
    const consumer = self.read(k);
    var i = 0;
    while(i < list.len) {
      if(Strings.new(list[i].type.originalUrl).contains(k)
        && mem.eq(u8, list[i].status, @constCast("lock"))
        && mem.eq(u8, consumer.status, @constCast("updated"))) {
        list[i].status = "unlock";
        i=list.len;
      }
      i=i+1;
    }
  }
  
  pub fn register(self:*Datagram, c:Consumer) void {
    const dchannel = channel.asFlowChannel().asDatagramChannel();
    dchannel.add(c);
  }
  
  pub fn keys(self:*Datagram) List(Strings) {
    const dchannel = channel.asFlowChannel().asDatagramChannel();
    const list = dchannel.get();
    var allkeys = List(Strings);
    allkeys.items = &buffer;
    var i=0;
    while(i<list.len) {
      allkeys.items[allkeys.len] = list[i].key;
      i=i+1;
    }
    return allkeys;
  }
  
  pub fn write(self:*Datagram, k:[] const u8, data:[]const u8) void {
    const dchannel = channel.asFlowChannel().asDatagramChannel();
    dchannel.edit(k, data);
  }
  
  pub fn read(self:*Datagram, k:[]const u8) Consumer {
    const dchannel = channel.asFlowChannel().asDatagramChannel();
    return dchannel.getKey(k);
  }
}

///proxy
const Dispatcher = struct { 
  pub fn checkAvailability(self:*Dispatcher, datagram: Datagram, key:[]const u8) bool {
    const repo = datagram.channel.asRepository();
    const list = repo.get();
    const consumer = datagram.read(k);
    var event = EventHistory{};
    var i = 0;
    while(i < list.len) {
      if(Strings.new(list[i].type.originalUrl).contains(k)
        && mem.eq(u8, list[i].status, @constCast("lock"))) {
        event = list[i];
        i=list.len;
      }
      i=i+1;
    }
    request
  }
  
  pub fn requestCli(self:*Dispatcher, datagram: Datagram, key:[]const u8, msg:[]const u8, info:[]const u8) !void {
    const nchannel = datagram.channel.asNotificationChannel();
    const flowReq = FlowRequest{};
    flowReq.key = self.keyId;
    flowReq.msg = msg;
    flowReq.status = "checked";
    flowReq.info = info;
    const s = datagram.read(k).asSubscriber();
    const n = Notification{.event=event, .s=s, .flowReq=flowReq};
    try nchannel.save(n);
  }
  
  pub fn request(self:*Dispatcher, datagram:Datagram, key:[]const u8, msg:[]const u8) void {
    const fchannel = datagram.channel.asFlowChannel();
    var flowReq = fchannel.getKey(key);
    flowReq.status = "dispatched";
    flowReq.info = msg;
    try fchannel.edit(fchannel, FlowRequest{}, flow, k, msg);
    
  }
  
}

const Notification = struct {
  event:EventHistory,
  s:Subscriber,
  flowReq:FlowRequest,
  
  createWith(self:*Notification, channel: NotificationChannel) void {
    channel.save(channel, self);
  }
  
}

const Producer = struct {
  id:i32,
  
  pub fn asPublisher(self*Producer) Publisher {
    return Publisher{};
  }
  
  pub fn asDatagram(self*Producer) Datagram {
    return Datagram{};
  }
  
}
  

const Consumer = struct {
  id:[]u8,
  keyId:[]u8,
  fullname:[]u8,
  company:[]u8,
  email:[]u8,
  password:[]u8,
  created:[]u8,
  data:[]u8,
  
  pub fn asSubscriber(self:*Consumer) Subscriber {
    return Subscriber{.id=self.id};
  }
  
  pub fn request(self:*Consumer, datagram:Datagram, msg:[]const u8) !void {
    const fchannel = datagram.channel.asFlowChannel();
    const flowReq = FlowRequest{};
    flowReq.key = self.keyId;
    flowReq.msg = msg;
    flowReq.status = "new";
    try fchannel.save(fchannel, FlowRequest{}, flow, flowReq);
  }
  
}

const FlowRequest = struct {
  key:[]u8,
  msg:[]u8,
  status:[]u8,
  data:[]u8
}

const Subscriber = struct {
  id:[]u8,
  
  pub fn subscribe(self:*Subscriber, channel: TopicChannel, topic:Topic) {
    const len = topic.subscribers.len;
    const all = channel.get();
    var i=0;
    while(i<all.len) {
      if(all[i].id == topic.id) {
        topic.subscribers[len] = self;
        i=all.len;
      }
      i=i+1;
    }
  }
  
  pub fn notifications(self:*Subscriber, channel:NotificationChannel) []Notification {
    const all = channel.get();
    var list:[]Notification = undefined;
    var i=0;
    while(i<all.len) {
      if(all[i].subscriber.id == self.id) {
        list[i] = all[i];
      }
      i=i+1;
    }
    return list;
  }
  
}

const Publisher = struct {
  id:i32,
  
  pub fn notify(s: Subscriber, event:EventHistory, channel:NotificationChannel) void {
    const n = Notification{.event=event, .s=s, .flowReq=undefine};};
    n.createWith(channel);
  }
  
  pub fn asSubject(self:*Publisher) Subject {
    return Subject{.id=self.id};
  }
  
  pub fn createTopic(self:*Publisher, channel:TopicChannel, t:Topic) {
    channel.add(t);
  }
  
  pub subscribers(self:*Publisher, channel:TopicChannel, t:Topic) []Subscriber {
    const all = channel.get();
    var list:[]Subscriber = undefined;
    var i=0;
    while(i<all.len) {
      if(all[i].id == topic.id) {
        list = all[i].subscribers;
      }
      i=i+1;
    }
    return list;
  }
    
}}
